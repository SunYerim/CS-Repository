## TLS/SSL HandShake
HTTPS에서 클라이언트와 서버간 통신 전 SSL 인증서로 신뢰성 여부를 판단하기 위해 연결하는 방식
<br>
→ ```SSL```이 발전되어 ```TLS(Transport Layer Security)```이라는 용어로 변경되었다.

<br>

### 대칭 키와 비대칭 키
---
- 대칭 키(비밀 키)
    - 하나의 키로 암호화하고 복호화한다. 해당 키가 노출된다면 보안 상 아주 치명적인 문제가 발생한다.

- 비대칭 키(공개 키)
    - 공개 키와 개인 키로 암호화 및 복호화를 수행한다. 
    - 공개 키로 데이터를 암호화하면 반드시 개인 키로만 복호화 가능하고, 개인 키로 데이터를 암호화하면 공개 키로만 복호화 할 수 이다.

<br><br>

💡 ***SSL은 대칭 키 방식과 비대칭 키 방식을 섞어서 사용한다.***

<br>

### 순서
<img src="https://github.com/user-attachments/assets/9a6642de-5adf-487b-bcca-6ebdb50ed974"> 
노란색 칸에 해당하는 패킷들이 SSL Handshake라고 보면 된다
<br><br>

---
1. 클라이언트는 서버에게 ```client hello``` 메시지를 담아 서버로 보낸다. 이때 암호화된 정보를 함께 담는데 버전, 암호 알고리즘, 압축 방식 등을 담는다.

    > ***ClientHello*** <br>
    클라이언트가 서버에 연결을 시도하며 전송하는 패킷

<br>

2. 서버는 클라이언트가 보낸 암호 알고리즘과 압축 방식을 받고, 세션 ID와 CA 공개 인증서를 ```server hello``` 메시지와 함께 담아 응답한다. 
    - 이 CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있다. <br>

    > ***CA*** <br>
    인증서의 역할은 <u>클라이언트가 접속한 서버가 의도한 서버가 맞는지 보장</u>하는 것이다. 이 역할을 하는 민간 기업들이 있는데 이런 기업들을 CA 혹은 Root Certificate라고 부른다. 

    <br>

    > ***ServerHello*** <br>
    서버는 클라이언트가 보낸 ClientHello 패킷을 받아 Cipher Suite(SSL 프로토콜 버전, 인증서 검정 등의 정보를 담고 있는 존재) 중 하나를 선택한 다음 클라이언트에게 이를 알린다. 또한 자신의 SSL 프로토콜 버전 등도 같이 보낸다.

<br>

3. 클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한 지 CA 목록에서 확인하는 과정을 진행한다.

<br>

4. CA 인증서에 대한 신뢰성이 확보되었다면 **클라이언트는 난수 바이트를 생성**하여 서버의 공개키로 암호화한다. 
    - 이 ```난수 바이트는 대칭키```를 정하는데 사용이 되고, 앞으로 서로 메시지를 통신할 때 암호화하는데 사용된다.

<br>

5. 만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구했다면 클라이언트의 인증서와 클라이언트의 개인키로 암호화된 임의의 바이트 문자열을 함께 보내준다.

<br>

6. 서버는 클라이언트의 인증서를 확인 후, 난수 바이트를 자신의 개인키로 복호화 후 대칭 마스터 키 생성에 활용한다.

<br>

7. 클라이언트는 handshake 과정이 완료되었다는 ```finished``` 메시지를 서버에 보내면서 지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보내준다. <br>
     > ***Finished 패킷*** <br>
     SSL HandShake 종료

<br>

8. 서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는 지 확인한다. 일치하면 서버도 마찬가지로 finished 메시지를 이번에 만든 대칭키로 암호화하여 보낸다.

<br>

9. 클라이언트는 해당 메시지를 대칭키로 복호화하여 서로 통신이 가능한 신뢰받은 사용자란 걸 인지하고 앞으로 클라이언트와 서버는 해당 대칭키로 데이터를 주고 받을 수 있다.

<br><br>
> 📢 ***정리***<br><br>
서버는 CA에 사이트 정보와 공개 키 전달하여 인증서 받음 → 클라이언트는 브라우저에 CA 공개키가 내장되어 있다고 가정 → ClientHello(암호화 알고리즘 나열 및 전달) → ServerHello(암호화 알고리즘 선택) → Server Certificate(인증서 전달) → Client Key Exchange (데이터를 암호화 할 대칭 키 전달) → Client / ServerHello done (정보 전달 완료) → Finished(SSL Handshake 종료)

<br><br>
### 면접 질문 예상
---
<details>
  <summary>SSL Handshake에 대해서 설명해주세요.</summary>
    <br>
    클라이언트는 TCP 3way handshake를 수행한 이후 Client Hello를 전송하고, 서버는 인증서를 보냅니다.
    <br><br>
    클라이언트는 받은 인증서를 신뢰하기 위해서 등록된 인증기관인지 확인합니다. 이 인증서는 인증기관의 개인키로 암호화되었고, 공개키로 검증할 수 있습니다. 클라이언트는 사이트의 정보와 서버의 공개키를 얻을 수 있습니다.
    <br><br>
    서버의 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 보냅니다. 서버는 이를 개인키로 확인하고 이후 통신은 공유된 비밀키로 암호화되어 통신합니다.
    <br><br>
</details>
<br>
<details>
  <summary>왜 공개키 암호화와 비밀키 암호화를 복합적으로 사용했는지 설명해주세요.</summary>
    
</details>

<br><br>

**[참고]** <br> https://steady-coding.tistory.com/512
